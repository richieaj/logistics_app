import { Injectable, inject } from '@angular/core';
import { Router } from '@angular/router';
import { StoragePersistenceService } from '../storage/storage-persistence.service';
import * as i0 from "@angular/core";
const STORAGE_KEY = 'redirect';
export class AutoLoginService {
    constructor() {
        this.storageService = inject(StoragePersistenceService);
        this.router = inject(Router);
    }
    checkSavedRedirectRouteAndNavigate(config) {
        if (!config) {
            return;
        }
        const savedRouteForRedirect = this.getStoredRedirectRoute(config);
        if (savedRouteForRedirect != null) {
            this.deleteStoredRedirectRoute(config);
            this.router.navigateByUrl(savedRouteForRedirect);
        }
    }
    /**
     * Saves the redirect URL to storage.
     *
     * @param config The OpenId configuration.
     * @param url The redirect URL to save.
     */
    saveRedirectRoute(config, url) {
        if (!config) {
            return;
        }
        this.storageService.write(STORAGE_KEY, url, config);
    }
    /**
     * Gets the stored redirect URL from storage.
     */
    getStoredRedirectRoute(config) {
        return this.storageService.read(STORAGE_KEY, config);
    }
    /**
     * Removes the redirect URL from storage.
     */
    deleteStoredRedirectRoute(config) {
        this.storageService.remove(STORAGE_KEY, config);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: AutoLoginService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: AutoLoginService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: AutoLoginService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXV0by1sb2dpbi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvYW5ndWxhci1hdXRoLW9pZGMtY2xpZW50L3NyYy9saWIvYXV0by1sb2dpbi9hdXRvLWxvZ2luLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDbkQsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBRXpDLE9BQU8sRUFBRSx5QkFBeUIsRUFBRSxNQUFNLHdDQUF3QyxDQUFDOztBQUVuRixNQUFNLFdBQVcsR0FBRyxVQUFVLENBQUM7QUFHL0IsTUFBTSxPQUFPLGdCQUFnQjtJQUQ3QjtRQUVtQixtQkFBYyxHQUFHLE1BQU0sQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1FBRW5ELFdBQU0sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7S0F5QzFDO0lBdkNDLGtDQUFrQyxDQUFDLE1BQWtDO1FBQ25FLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNaLE9BQU87UUFDVCxDQUFDO1FBQ0QsTUFBTSxxQkFBcUIsR0FBRyxJQUFJLENBQUMsc0JBQXNCLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFbEUsSUFBSSxxQkFBcUIsSUFBSSxJQUFJLEVBQUUsQ0FBQztZQUNsQyxJQUFJLENBQUMseUJBQXlCLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDdkMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMscUJBQXFCLENBQUMsQ0FBQztRQUNuRCxDQUFDO0lBQ0gsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsaUJBQWlCLENBQUMsTUFBa0MsRUFBRSxHQUFXO1FBQy9ELElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNaLE9BQU87UUFDVCxDQUFDO1FBRUQsSUFBSSxDQUFDLGNBQWMsQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLEdBQUcsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUN0RCxDQUFDO0lBRUQ7O09BRUc7SUFDSyxzQkFBc0IsQ0FBQyxNQUEyQjtRQUN4RCxPQUFPLElBQUksQ0FBQyxjQUFjLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQ7O09BRUc7SUFDSyx5QkFBeUIsQ0FBQyxNQUEyQjtRQUMzRCxJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sQ0FBQyxXQUFXLEVBQUUsTUFBTSxDQUFDLENBQUM7SUFDbEQsQ0FBQzs4R0EzQ1UsZ0JBQWdCO2tIQUFoQixnQkFBZ0IsY0FESCxNQUFNOzsyRkFDbkIsZ0JBQWdCO2tCQUQ1QixVQUFVO21CQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIGluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUm91dGVyIH0gZnJvbSAnQGFuZ3VsYXIvcm91dGVyJztcbmltcG9ydCB7IE9wZW5JZENvbmZpZ3VyYXRpb24gfSBmcm9tICcuLi9jb25maWcvb3BlbmlkLWNvbmZpZ3VyYXRpb24nO1xuaW1wb3J0IHsgU3RvcmFnZVBlcnNpc3RlbmNlU2VydmljZSB9IGZyb20gJy4uL3N0b3JhZ2Uvc3RvcmFnZS1wZXJzaXN0ZW5jZS5zZXJ2aWNlJztcblxuY29uc3QgU1RPUkFHRV9LRVkgPSAncmVkaXJlY3QnO1xuXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIEF1dG9Mb2dpblNlcnZpY2Uge1xuICBwcml2YXRlIHJlYWRvbmx5IHN0b3JhZ2VTZXJ2aWNlID0gaW5qZWN0KFN0b3JhZ2VQZXJzaXN0ZW5jZVNlcnZpY2UpO1xuXG4gIHByaXZhdGUgcmVhZG9ubHkgcm91dGVyID0gaW5qZWN0KFJvdXRlcik7XG5cbiAgY2hlY2tTYXZlZFJlZGlyZWN0Um91dGVBbmROYXZpZ2F0ZShjb25maWc6IE9wZW5JZENvbmZpZ3VyYXRpb24gfCBudWxsKTogdm9pZCB7XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2F2ZWRSb3V0ZUZvclJlZGlyZWN0ID0gdGhpcy5nZXRTdG9yZWRSZWRpcmVjdFJvdXRlKGNvbmZpZyk7XG5cbiAgICBpZiAoc2F2ZWRSb3V0ZUZvclJlZGlyZWN0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuZGVsZXRlU3RvcmVkUmVkaXJlY3RSb3V0ZShjb25maWcpO1xuICAgICAgdGhpcy5yb3V0ZXIubmF2aWdhdGVCeVVybChzYXZlZFJvdXRlRm9yUmVkaXJlY3QpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTYXZlcyB0aGUgcmVkaXJlY3QgVVJMIHRvIHN0b3JhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSBjb25maWcgVGhlIE9wZW5JZCBjb25maWd1cmF0aW9uLlxuICAgKiBAcGFyYW0gdXJsIFRoZSByZWRpcmVjdCBVUkwgdG8gc2F2ZS5cbiAgICovXG4gIHNhdmVSZWRpcmVjdFJvdXRlKGNvbmZpZzogT3BlbklkQ29uZmlndXJhdGlvbiB8IG51bGwsIHVybDogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKCFjb25maWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnN0b3JhZ2VTZXJ2aWNlLndyaXRlKFNUT1JBR0VfS0VZLCB1cmwsIGNvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgc3RvcmVkIHJlZGlyZWN0IFVSTCBmcm9tIHN0b3JhZ2UuXG4gICAqL1xuICBwcml2YXRlIGdldFN0b3JlZFJlZGlyZWN0Um91dGUoY29uZmlnOiBPcGVuSWRDb25maWd1cmF0aW9uKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zdG9yYWdlU2VydmljZS5yZWFkKFNUT1JBR0VfS0VZLCBjb25maWcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIHJlZGlyZWN0IFVSTCBmcm9tIHN0b3JhZ2UuXG4gICAqL1xuICBwcml2YXRlIGRlbGV0ZVN0b3JlZFJlZGlyZWN0Um91dGUoY29uZmlnOiBPcGVuSWRDb25maWd1cmF0aW9uKTogdm9pZCB7XG4gICAgdGhpcy5zdG9yYWdlU2VydmljZS5yZW1vdmUoU1RPUkFHRV9LRVksIGNvbmZpZyk7XG4gIH1cbn1cbiJdfQ==