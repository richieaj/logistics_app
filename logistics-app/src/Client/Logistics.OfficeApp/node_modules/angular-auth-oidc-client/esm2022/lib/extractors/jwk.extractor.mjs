import { Injectable } from '@angular/core';
import * as i0 from "@angular/core";
export class JwkExtractor {
    extractJwk(keys, spec, throwOnEmpty = true) {
        if (0 === keys.length) {
            throw JwkExtractorInvalidArgumentError;
        }
        const foundKeys = keys
            .filter((k) => (spec?.kid ? k['kid'] === spec.kid : true))
            .filter((k) => (spec?.use ? k['use'] === spec.use : true))
            .filter((k) => (spec?.kty ? k['kty'] === spec.kty : true));
        if (foundKeys.length === 0 && throwOnEmpty) {
            throw JwkExtractorNoMatchingKeysError;
        }
        if (foundKeys.length > 1 && (null === spec || undefined === spec)) {
            throw JwkExtractorSeveralMatchingKeysError;
        }
        return foundKeys;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: JwkExtractor, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: JwkExtractor, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: JwkExtractor, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
function buildErrorName(name) {
    return JwkExtractor.name + ': ' + name;
}
export const JwkExtractorInvalidArgumentError = {
    name: buildErrorName('InvalidArgumentError'),
    message: 'Array of keys was empty. Unable to extract',
};
export const JwkExtractorNoMatchingKeysError = {
    name: buildErrorName('NoMatchingKeysError'),
    message: 'No key found matching the spec',
};
export const JwkExtractorSeveralMatchingKeysError = {
    name: buildErrorName('SeveralMatchingKeysError'),
    message: 'More than one key found. Please use spec to filter',
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiandrLmV4dHJhY3Rvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItYXV0aC1vaWRjLWNsaWVudC9zcmMvbGliL2V4dHJhY3RvcnMvandrLmV4dHJhY3Rvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDOztBQUczQyxNQUFNLE9BQU8sWUFBWTtJQUN2QixVQUFVLENBQ1IsSUFBa0IsRUFDbEIsSUFBbUQsRUFDbkQsWUFBWSxHQUFHLElBQUk7UUFFbkIsSUFBSSxDQUFDLEtBQUssSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ3RCLE1BQU0sZ0NBQWdDLENBQUM7UUFDekMsQ0FBQztRQUVELE1BQU0sU0FBUyxHQUFHLElBQUk7YUFDbkIsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFFLENBQVMsQ0FBQyxLQUFLLENBQUMsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQzthQUNsRSxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3pELE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxJQUFJLEVBQUUsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUU3RCxJQUFJLFNBQVMsQ0FBQyxNQUFNLEtBQUssQ0FBQyxJQUFJLFlBQVksRUFBRSxDQUFDO1lBQzNDLE1BQU0sK0JBQStCLENBQUM7UUFDeEMsQ0FBQztRQUVELElBQUksU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLEtBQUssSUFBSSxJQUFJLFNBQVMsS0FBSyxJQUFJLENBQUMsRUFBRSxDQUFDO1lBQ2xFLE1BQU0sb0NBQW9DLENBQUM7UUFDN0MsQ0FBQztRQUVELE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7OEdBeEJVLFlBQVk7a0hBQVosWUFBWSxjQURDLE1BQU07OzJGQUNuQixZQUFZO2tCQUR4QixVQUFVO21CQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRTs7QUE0QmxDLFNBQVMsY0FBYyxDQUFDLElBQVk7SUFDbEMsT0FBTyxZQUFZLENBQUMsSUFBSSxHQUFHLElBQUksR0FBRyxJQUFJLENBQUM7QUFDekMsQ0FBQztBQUVELE1BQU0sQ0FBQyxNQUFNLGdDQUFnQyxHQUFHO0lBQzlDLElBQUksRUFBRSxjQUFjLENBQUMsc0JBQXNCLENBQUM7SUFDNUMsT0FBTyxFQUFFLDRDQUE0QztDQUN0RCxDQUFDO0FBRUYsTUFBTSxDQUFDLE1BQU0sK0JBQStCLEdBQUc7SUFDN0MsSUFBSSxFQUFFLGNBQWMsQ0FBQyxxQkFBcUIsQ0FBQztJQUMzQyxPQUFPLEVBQUUsZ0NBQWdDO0NBQzFDLENBQUM7QUFFRixNQUFNLENBQUMsTUFBTSxvQ0FBb0MsR0FBRztJQUNsRCxJQUFJLEVBQUUsY0FBYyxDQUFDLDBCQUEwQixDQUFDO0lBQ2hELE9BQU8sRUFBRSxvREFBb0Q7Q0FDOUQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBKd2tFeHRyYWN0b3Ige1xuICBleHRyYWN0SndrKFxuICAgIGtleXM6IEpzb25XZWJLZXlbXSxcbiAgICBzcGVjPzogeyBraWQ/OiBzdHJpbmc7IHVzZT86IHN0cmluZzsga3R5Pzogc3RyaW5nIH0sXG4gICAgdGhyb3dPbkVtcHR5ID0gdHJ1ZVxuICApOiBKc29uV2ViS2V5W10ge1xuICAgIGlmICgwID09PSBrZXlzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgSndrRXh0cmFjdG9ySW52YWxpZEFyZ3VtZW50RXJyb3I7XG4gICAgfVxuXG4gICAgY29uc3QgZm91bmRLZXlzID0ga2V5c1xuICAgICAgLmZpbHRlcigoaykgPT4gKHNwZWM/LmtpZCA/IChrIGFzIGFueSlbJ2tpZCddID09PSBzcGVjLmtpZCA6IHRydWUpKVxuICAgICAgLmZpbHRlcigoaykgPT4gKHNwZWM/LnVzZSA/IGtbJ3VzZSddID09PSBzcGVjLnVzZSA6IHRydWUpKVxuICAgICAgLmZpbHRlcigoaykgPT4gKHNwZWM/Lmt0eSA/IGtbJ2t0eSddID09PSBzcGVjLmt0eSA6IHRydWUpKTtcblxuICAgIGlmIChmb3VuZEtleXMubGVuZ3RoID09PSAwICYmIHRocm93T25FbXB0eSkge1xuICAgICAgdGhyb3cgSndrRXh0cmFjdG9yTm9NYXRjaGluZ0tleXNFcnJvcjtcbiAgICB9XG5cbiAgICBpZiAoZm91bmRLZXlzLmxlbmd0aCA+IDEgJiYgKG51bGwgPT09IHNwZWMgfHwgdW5kZWZpbmVkID09PSBzcGVjKSkge1xuICAgICAgdGhyb3cgSndrRXh0cmFjdG9yU2V2ZXJhbE1hdGNoaW5nS2V5c0Vycm9yO1xuICAgIH1cblxuICAgIHJldHVybiBmb3VuZEtleXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRFcnJvck5hbWUobmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIEp3a0V4dHJhY3Rvci5uYW1lICsgJzogJyArIG5hbWU7XG59XG5cbmV4cG9ydCBjb25zdCBKd2tFeHRyYWN0b3JJbnZhbGlkQXJndW1lbnRFcnJvciA9IHtcbiAgbmFtZTogYnVpbGRFcnJvck5hbWUoJ0ludmFsaWRBcmd1bWVudEVycm9yJyksXG4gIG1lc3NhZ2U6ICdBcnJheSBvZiBrZXlzIHdhcyBlbXB0eS4gVW5hYmxlIHRvIGV4dHJhY3QnLFxufTtcblxuZXhwb3J0IGNvbnN0IEp3a0V4dHJhY3Rvck5vTWF0Y2hpbmdLZXlzRXJyb3IgPSB7XG4gIG5hbWU6IGJ1aWxkRXJyb3JOYW1lKCdOb01hdGNoaW5nS2V5c0Vycm9yJyksXG4gIG1lc3NhZ2U6ICdObyBrZXkgZm91bmQgbWF0Y2hpbmcgdGhlIHNwZWMnLFxufTtcblxuZXhwb3J0IGNvbnN0IEp3a0V4dHJhY3RvclNldmVyYWxNYXRjaGluZ0tleXNFcnJvciA9IHtcbiAgbmFtZTogYnVpbGRFcnJvck5hbWUoJ1NldmVyYWxNYXRjaGluZ0tleXNFcnJvcicpLFxuICBtZXNzYWdlOiAnTW9yZSB0aGFuIG9uZSBrZXkgZm91bmQuIFBsZWFzZSB1c2Ugc3BlYyB0byBmaWx0ZXInLFxufTtcbiJdfQ==