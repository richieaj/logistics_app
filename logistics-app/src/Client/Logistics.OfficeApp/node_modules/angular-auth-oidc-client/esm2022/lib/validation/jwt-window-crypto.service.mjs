import { inject, Injectable } from '@angular/core';
import { from } from 'rxjs';
import { map } from 'rxjs/operators';
import { CryptoService } from '../utils/crypto/crypto.service';
import * as i0 from "@angular/core";
export class JwtWindowCryptoService {
    constructor() {
        this.cryptoService = inject(CryptoService);
    }
    generateCodeChallenge(codeVerifier) {
        return this.calcHash(codeVerifier).pipe(map((challengeRaw) => this.base64UrlEncode(challengeRaw)));
    }
    generateAtHash(accessToken, algorithm) {
        return this.calcHash(accessToken, algorithm).pipe(map((tokenHash) => {
            const substr = tokenHash.substr(0, tokenHash.length / 2);
            const tokenHashBase64 = btoa(substr);
            return tokenHashBase64
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=/g, '');
        }));
    }
    calcHash(valueToHash, algorithm = 'SHA-256') {
        const msgBuffer = new TextEncoder().encode(valueToHash);
        return from(this.cryptoService.getCrypto().subtle.digest(algorithm, msgBuffer)).pipe(map((hashBuffer) => {
            const buffer = hashBuffer;
            const hashArray = Array.from(new Uint8Array(buffer));
            return this.toHashString(hashArray);
        }));
    }
    toHashString(byteArray) {
        let result = '';
        for (const e of byteArray) {
            result += String.fromCharCode(e);
        }
        return result;
    }
    base64UrlEncode(str) {
        const base64 = btoa(str);
        return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: JwtWindowCryptoService, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: JwtWindowCryptoService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.1", ngImport: i0, type: JwtWindowCryptoService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiand0LXdpbmRvdy1jcnlwdG8uc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXItYXV0aC1vaWRjLWNsaWVudC9zcmMvbGliL3ZhbGlkYXRpb24vand0LXdpbmRvdy1jcnlwdG8uc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEVBQUUsSUFBSSxFQUFjLE1BQU0sTUFBTSxDQUFDO0FBQ3hDLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNyQyxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sZ0NBQWdDLENBQUM7O0FBRy9ELE1BQU0sT0FBTyxzQkFBc0I7SUFEbkM7UUFFbUIsa0JBQWEsR0FBRyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7S0F1RHhEO0lBckRDLHFCQUFxQixDQUFDLFlBQW9CO1FBQ3hDLE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxZQUFZLENBQUMsQ0FBQyxJQUFJLENBQ3JDLEdBQUcsQ0FBQyxDQUFDLFlBQW9CLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FDbEUsQ0FBQztJQUNKLENBQUM7SUFFRCxjQUFjLENBQUMsV0FBbUIsRUFBRSxTQUFpQjtRQUNuRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQUMsV0FBVyxFQUFFLFNBQVMsQ0FBQyxDQUFDLElBQUksQ0FDL0MsR0FBRyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUU7WUFDaEIsTUFBTSxNQUFNLEdBQVcsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQztZQUNqRSxNQUFNLGVBQWUsR0FBVyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7WUFFN0MsT0FBTyxlQUFlO2lCQUNuQixPQUFPLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQztpQkFDbkIsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLENBQUM7aUJBQ25CLE9BQU8sQ0FBQyxJQUFJLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDdkIsQ0FBQyxDQUFDLENBQ0gsQ0FBQztJQUNKLENBQUM7SUFFTyxRQUFRLENBQ2QsV0FBbUIsRUFDbkIsU0FBUyxHQUFHLFNBQVM7UUFFckIsTUFBTSxTQUFTLEdBQWUsSUFBSSxXQUFXLEVBQUUsQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7UUFFcEUsT0FBTyxJQUFJLENBQ1QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxTQUFTLEVBQUUsQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxTQUFTLENBQUMsQ0FDbkUsQ0FBQyxJQUFJLENBQ0osR0FBRyxDQUFDLENBQUMsVUFBbUIsRUFBRSxFQUFFO1lBQzFCLE1BQU0sTUFBTSxHQUFHLFVBQXlCLENBQUM7WUFDekMsTUFBTSxTQUFTLEdBQWEsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFJLFVBQVUsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBRS9ELE9BQU8sSUFBSSxDQUFDLFlBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUN0QyxDQUFDLENBQUMsQ0FDSCxDQUFDO0lBQ0osQ0FBQztJQUVPLFlBQVksQ0FBQyxTQUFtQjtRQUN0QyxJQUFJLE1BQU0sR0FBRyxFQUFFLENBQUM7UUFFaEIsS0FBSyxNQUFNLENBQUMsSUFBSSxTQUFTLEVBQUUsQ0FBQztZQUMxQixNQUFNLElBQUksTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUNuQyxDQUFDO1FBRUQsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVPLGVBQWUsQ0FBQyxHQUFXO1FBQ2pDLE1BQU0sTUFBTSxHQUFXLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUVqQyxPQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLEdBQUcsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsQ0FBQztJQUMxRSxDQUFDOzhHQXZEVSxzQkFBc0I7a0hBQXRCLHNCQUFzQixjQURULE1BQU07OzJGQUNuQixzQkFBc0I7a0JBRGxDLFVBQVU7bUJBQUMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW5qZWN0LCBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBmcm9tLCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBDcnlwdG9TZXJ2aWNlIH0gZnJvbSAnLi4vdXRpbHMvY3J5cHRvL2NyeXB0by5zZXJ2aWNlJztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBKd3RXaW5kb3dDcnlwdG9TZXJ2aWNlIHtcbiAgcHJpdmF0ZSByZWFkb25seSBjcnlwdG9TZXJ2aWNlID0gaW5qZWN0KENyeXB0b1NlcnZpY2UpO1xuXG4gIGdlbmVyYXRlQ29kZUNoYWxsZW5nZShjb2RlVmVyaWZpZXI6IHN0cmluZyk6IE9ic2VydmFibGU8c3RyaW5nPiB7XG4gICAgcmV0dXJuIHRoaXMuY2FsY0hhc2goY29kZVZlcmlmaWVyKS5waXBlKFxuICAgICAgbWFwKChjaGFsbGVuZ2VSYXc6IHN0cmluZykgPT4gdGhpcy5iYXNlNjRVcmxFbmNvZGUoY2hhbGxlbmdlUmF3KSlcbiAgICApO1xuICB9XG5cbiAgZ2VuZXJhdGVBdEhhc2goYWNjZXNzVG9rZW46IHN0cmluZywgYWxnb3JpdGhtOiBzdHJpbmcpOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuICAgIHJldHVybiB0aGlzLmNhbGNIYXNoKGFjY2Vzc1Rva2VuLCBhbGdvcml0aG0pLnBpcGUoXG4gICAgICBtYXAoKHRva2VuSGFzaCkgPT4ge1xuICAgICAgICBjb25zdCBzdWJzdHI6IHN0cmluZyA9IHRva2VuSGFzaC5zdWJzdHIoMCwgdG9rZW5IYXNoLmxlbmd0aCAvIDIpO1xuICAgICAgICBjb25zdCB0b2tlbkhhc2hCYXNlNjQ6IHN0cmluZyA9IGJ0b2Eoc3Vic3RyKTtcblxuICAgICAgICByZXR1cm4gdG9rZW5IYXNoQmFzZTY0XG4gICAgICAgICAgLnJlcGxhY2UoL1xcKy9nLCAnLScpXG4gICAgICAgICAgLnJlcGxhY2UoL1xcLy9nLCAnXycpXG4gICAgICAgICAgLnJlcGxhY2UoLz0vZywgJycpO1xuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjSGFzaChcbiAgICB2YWx1ZVRvSGFzaDogc3RyaW5nLFxuICAgIGFsZ29yaXRobSA9ICdTSEEtMjU2J1xuICApOiBPYnNlcnZhYmxlPHN0cmluZz4ge1xuICAgIGNvbnN0IG1zZ0J1ZmZlcjogVWludDhBcnJheSA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZVRvSGFzaCk7XG5cbiAgICByZXR1cm4gZnJvbShcbiAgICAgIHRoaXMuY3J5cHRvU2VydmljZS5nZXRDcnlwdG8oKS5zdWJ0bGUuZGlnZXN0KGFsZ29yaXRobSwgbXNnQnVmZmVyKVxuICAgICkucGlwZShcbiAgICAgIG1hcCgoaGFzaEJ1ZmZlcjogdW5rbm93bikgPT4ge1xuICAgICAgICBjb25zdCBidWZmZXIgPSBoYXNoQnVmZmVyIGFzIEFycmF5QnVmZmVyO1xuICAgICAgICBjb25zdCBoYXNoQXJyYXk6IG51bWJlcltdID0gQXJyYXkuZnJvbShuZXcgVWludDhBcnJheShidWZmZXIpKTtcblxuICAgICAgICByZXR1cm4gdGhpcy50b0hhc2hTdHJpbmcoaGFzaEFycmF5KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgdG9IYXNoU3RyaW5nKGJ5dGVBcnJheTogbnVtYmVyW10pOiBzdHJpbmcge1xuICAgIGxldCByZXN1bHQgPSAnJztcblxuICAgIGZvciAoY29uc3QgZSBvZiBieXRlQXJyYXkpIHtcbiAgICAgIHJlc3VsdCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcml2YXRlIGJhc2U2NFVybEVuY29kZShzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgYmFzZTY0OiBzdHJpbmcgPSBidG9hKHN0cik7XG5cbiAgICByZXR1cm4gYmFzZTY0LnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpLnJlcGxhY2UoLz0vZywgJycpO1xuICB9XG59XG4iXX0=