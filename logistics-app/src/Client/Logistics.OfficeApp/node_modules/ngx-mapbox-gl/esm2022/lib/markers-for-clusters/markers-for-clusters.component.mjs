import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChild, Directive, Input, NgZone, TemplateRef, } from '@angular/core';
import { fromEvent, merge, Subscription } from 'rxjs';
import { filter, startWith, switchMap } from 'rxjs/operators';
import { MapService } from '../map/map.service';
import * as i0 from "@angular/core";
import * as i1 from "../map/map.service";
import * as i2 from "@angular/common";
import * as i3 from "../layer/layer.component";
import * as i4 from "../marker/marker.component";
export class PointDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: PointDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.1.2", type: PointDirective, selector: "ng-template[mglPoint]", ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: PointDirective, decorators: [{
            type: Directive,
            args: [{ selector: 'ng-template[mglPoint]' }]
        }] });
export class ClusterPointDirective {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: ClusterPointDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.1.2", type: ClusterPointDirective, selector: "ng-template[mglClusterPoint]", ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: ClusterPointDirective, decorators: [{
            type: Directive,
            args: [{ selector: 'ng-template[mglClusterPoint]' }]
        }] });
let uniqId = 0;
export class MarkersForClustersComponent {
    constructor(mapService, ChangeDetectorRef, zone) {
        this.mapService = mapService;
        this.ChangeDetectorRef = ChangeDetectorRef;
        this.zone = zone;
        this.layerId = `mgl-markers-for-clusters-${uniqId++}`;
        this.sub = new Subscription();
    }
    ngAfterContentInit() {
        const clusterDataUpdate = () => fromEvent(this.mapService.mapInstance, 'data').pipe(filter((e) => e.sourceId === this.source &&
            e.sourceDataType !== 'metadata' &&
            this.mapService.mapInstance.isSourceLoaded(this.source)));
        const sub = this.mapService.mapCreated$
            .pipe(switchMap(clusterDataUpdate), switchMap(() => merge(fromEvent(this.mapService.mapInstance, 'move'), fromEvent(this.mapService.mapInstance, 'moveend')).pipe(startWith(undefined))))
            .subscribe(() => {
            this.zone.run(() => {
                this.updateCluster();
            });
        });
        this.sub.add(sub);
    }
    ngOnDestroy() {
        this.sub.unsubscribe();
    }
    trackByClusterPoint(_index, clusterPoint) {
        return clusterPoint.id;
    }
    updateCluster() {
        // Invalid queryRenderedFeatures typing
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const params = { layers: [this.layerId] };
        if (!this.pointTpl) {
            params.filter = ['==', 'cluster', true];
        }
        this.clusterPoints =
            this.mapService.mapInstance.queryRenderedFeatures(params);
        this.ChangeDetectorRef.markForCheck();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: MarkersForClustersComponent, deps: [{ token: i1.MapService }, { token: i0.ChangeDetectorRef }, { token: i0.NgZone }], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "18.1.2", type: MarkersForClustersComponent, selector: "mgl-markers-for-clusters", inputs: { source: "source" }, queries: [{ propertyName: "pointTpl", first: true, predicate: PointDirective, descendants: true, read: TemplateRef }, { propertyName: "clusterPointTpl", first: true, predicate: ClusterPointDirective, descendants: true, read: TemplateRef }], ngImport: i0, template: `
    <mgl-layer
      [id]="layerId"
      [source]="source"
      type="circle"
      [paint]="{ 'circle-radius': 0 }"
    ></mgl-layer>
    <ng-container
      *ngFor="let feature of clusterPoints; trackBy: trackByClusterPoint"
    >
      <ng-container *ngIf="feature.properties!['cluster']">
        <mgl-marker [feature]="$any(feature)">
          <ng-container
            *ngTemplateOutlet="clusterPointTpl; context: { $implicit: feature }"
          ></ng-container>
        </mgl-marker>
      </ng-container>
      <ng-container *ngIf="!feature.properties!['cluster']">
        <mgl-marker [feature]="$any(feature)">
          <ng-container
            *ngTemplateOutlet="pointTpl!; context: { $implicit: feature }"
          ></ng-container>
        </mgl-marker>
      </ng-container>
    </ng-container>
  `, isInline: true, dependencies: [{ kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i2.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "component", type: i3.LayerComponent, selector: "mgl-layer", inputs: ["id", "source", "type", "metadata", "sourceLayer", "filter", "layout", "paint", "before", "minzoom", "maxzoom"], outputs: ["layerClick", "layerDblClick", "layerMouseDown", "layerMouseUp", "layerMouseEnter", "layerMouseLeave", "layerMouseMove", "layerMouseOver", "layerMouseOut", "layerContextMenu", "layerTouchStart", "layerTouchEnd", "layerTouchCancel", "click", "dblClick", "mouseDown", "mouseUp", "mouseEnter", "mouseLeave", "mouseMove", "mouseOver", "mouseOut", "contextMenu", "touchStart", "touchEnd", "touchCancel"] }, { kind: "component", type: i4.MarkerComponent, selector: "mgl-marker", inputs: ["offset", "anchor", "clickTolerance", "feature", "lngLat", "draggable", "popupShown", "className", "pitchAlignment", "rotationAlignment"], outputs: ["markerDragStart", "markerDragEnd", "markerDrag", "dragStart", "dragEnd", "drag"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.1.2", ngImport: i0, type: MarkersForClustersComponent, decorators: [{
            type: Component,
            args: [{
                    selector: 'mgl-markers-for-clusters',
                    template: `
    <mgl-layer
      [id]="layerId"
      [source]="source"
      type="circle"
      [paint]="{ 'circle-radius': 0 }"
    ></mgl-layer>
    <ng-container
      *ngFor="let feature of clusterPoints; trackBy: trackByClusterPoint"
    >
      <ng-container *ngIf="feature.properties!['cluster']">
        <mgl-marker [feature]="$any(feature)">
          <ng-container
            *ngTemplateOutlet="clusterPointTpl; context: { $implicit: feature }"
          ></ng-container>
        </mgl-marker>
      </ng-container>
      <ng-container *ngIf="!feature.properties!['cluster']">
        <mgl-marker [feature]="$any(feature)">
          <ng-container
            *ngTemplateOutlet="pointTpl!; context: { $implicit: feature }"
          ></ng-container>
        </mgl-marker>
      </ng-container>
    </ng-container>
  `,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                }]
        }], ctorParameters: () => [{ type: i1.MapService }, { type: i0.ChangeDetectorRef }, { type: i0.NgZone }], propDecorators: { source: [{
                type: Input
            }], pointTpl: [{
                type: ContentChild,
                args: [PointDirective, { read: TemplateRef, static: false }]
            }], clusterPointTpl: [{
                type: ContentChild,
                args: [ClusterPointDirective, { read: TemplateRef, static: false }]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFya2Vycy1mb3ItY2x1c3RlcnMuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vbGlicy9uZ3gtbWFwYm94LWdsL3NyYy9saWIvbWFya2Vycy1mb3ItY2x1c3RlcnMvbWFya2Vycy1mb3ItY2x1c3RlcnMuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFFTCx1QkFBdUIsRUFDdkIsaUJBQWlCLEVBQ2pCLFNBQVMsRUFDVCxZQUFZLEVBQ1osU0FBUyxFQUNULEtBQUssRUFDTCxNQUFNLEVBRU4sV0FBVyxHQUNaLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN0RCxPQUFPLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUM5RCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7Ozs7OztBQUdoRCxNQUFNLE9BQU8sY0FBYzs4R0FBZCxjQUFjO2tHQUFkLGNBQWM7OzJGQUFkLGNBQWM7a0JBRDFCLFNBQVM7bUJBQUMsRUFBRSxRQUFRLEVBQUUsdUJBQXVCLEVBQUU7O0FBSWhELE1BQU0sT0FBTyxxQkFBcUI7OEdBQXJCLHFCQUFxQjtrR0FBckIscUJBQXFCOzsyRkFBckIscUJBQXFCO2tCQURqQyxTQUFTO21CQUFDLEVBQUUsUUFBUSxFQUFFLDhCQUE4QixFQUFFOztBQUd2RCxJQUFJLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFpQ2YsTUFBTSxPQUFPLDJCQUEyQjtJQWdCdEMsWUFDVSxVQUFzQixFQUN0QixpQkFBb0MsRUFDcEMsSUFBWTtRQUZaLGVBQVUsR0FBVixVQUFVLENBQVk7UUFDdEIsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQUNwQyxTQUFJLEdBQUosSUFBSSxDQUFRO1FBUHRCLFlBQU8s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LElBQUksRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFmdGVyQ29udGVudEluaXQsXG4gIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICBDaGFuZ2VEZXRlY3RvclJlZixcbiAgQ29tcG9uZW50LFxuICBDb250ZW50Q2hpbGQsXG4gIERpcmVjdGl2ZSxcbiAgSW5wdXQsXG4gIE5nWm9uZSxcbiAgT25EZXN0cm95LFxuICBUZW1wbGF0ZVJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBNYXBib3hHZW9KU09ORmVhdHVyZSwgTWFwU291cmNlRGF0YUV2ZW50IH0gZnJvbSAnbWFwYm94LWdsJztcbmltcG9ydCB7IGZyb21FdmVudCwgbWVyZ2UsIFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZmlsdGVyLCBzdGFydFdpdGgsIHN3aXRjaE1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IE1hcFNlcnZpY2UgfSBmcm9tICcuLi9tYXAvbWFwLnNlcnZpY2UnO1xuXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICduZy10ZW1wbGF0ZVttZ2xQb2ludF0nIH0pXG5leHBvcnQgY2xhc3MgUG9pbnREaXJlY3RpdmUge31cblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnbmctdGVtcGxhdGVbbWdsQ2x1c3RlclBvaW50XScgfSlcbmV4cG9ydCBjbGFzcyBDbHVzdGVyUG9pbnREaXJlY3RpdmUge31cblxubGV0IHVuaXFJZCA9IDA7XG5cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ21nbC1tYXJrZXJzLWZvci1jbHVzdGVycycsXG4gIHRlbXBsYXRlOiBgXG4gICAgPG1nbC1sYXllclxuICAgICAgW2lkXT1cImxheWVySWRcIlxuICAgICAgW3NvdXJjZV09XCJzb3VyY2VcIlxuICAgICAgdHlwZT1cImNpcmNsZVwiXG4gICAgICBbcGFpbnRdPVwieyAnY2lyY2xlLXJhZGl1cyc6IDAgfVwiXG4gICAgPjwvbWdsLWxheWVyPlxuICAgIDxuZy1jb250YWluZXJcbiAgICAgICpuZ0Zvcj1cImxldCBmZWF0dXJlIG9mIGNsdXN0ZXJQb2ludHM7IHRyYWNrQnk6IHRyYWNrQnlDbHVzdGVyUG9pbnRcIlxuICAgID5cbiAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCJmZWF0dXJlLnByb3BlcnRpZXMhWydjbHVzdGVyJ11cIj5cbiAgICAgICAgPG1nbC1tYXJrZXIgW2ZlYXR1cmVdPVwiJGFueShmZWF0dXJlKVwiPlxuICAgICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwiY2x1c3RlclBvaW50VHBsOyBjb250ZXh0OiB7ICRpbXBsaWNpdDogZmVhdHVyZSB9XCJcbiAgICAgICAgICA+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbWdsLW1hcmtlcj5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cIiFmZWF0dXJlLnByb3BlcnRpZXMhWydjbHVzdGVyJ11cIj5cbiAgICAgICAgPG1nbC1tYXJrZXIgW2ZlYXR1cmVdPVwiJGFueShmZWF0dXJlKVwiPlxuICAgICAgICAgIDxuZy1jb250YWluZXJcbiAgICAgICAgICAgICpuZ1RlbXBsYXRlT3V0bGV0PVwicG9pbnRUcGwhOyBjb250ZXh0OiB7ICRpbXBsaWNpdDogZmVhdHVyZSB9XCJcbiAgICAgICAgICA+PC9uZy1jb250YWluZXI+XG4gICAgICAgIDwvbWdsLW1hcmtlcj5cbiAgICAgIDwvbmctY29udGFpbmVyPlxuICAgIDwvbmctY29udGFpbmVyPlxuICBgLFxuICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgcHJlc2VydmVXaGl0ZXNwYWNlczogZmFsc2UsXG59KVxuZXhwb3J0IGNsYXNzIE1hcmtlcnNGb3JDbHVzdGVyc0NvbXBvbmVudFxuICBpbXBsZW1lbnRzIE9uRGVzdHJveSwgQWZ0ZXJDb250ZW50SW5pdFxue1xuICAvKiBJbml0IGlucHV0ICovXG4gIEBJbnB1dCgpIHNvdXJjZTogc3RyaW5nO1xuXG4gIEBDb250ZW50Q2hpbGQoUG9pbnREaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYsIHN0YXRpYzogZmFsc2UgfSlcbiAgcG9pbnRUcGw/OiBUZW1wbGF0ZVJlZjx1bmtub3duPjtcbiAgQENvbnRlbnRDaGlsZChDbHVzdGVyUG9pbnREaXJlY3RpdmUsIHsgcmVhZDogVGVtcGxhdGVSZWYsIHN0YXRpYzogZmFsc2UgfSlcbiAgY2x1c3RlclBvaW50VHBsOiBUZW1wbGF0ZVJlZjx1bmtub3duPjtcblxuICBjbHVzdGVyUG9pbnRzITogTWFwYm94R2VvSlNPTkZlYXR1cmVbXTsgLy8gSW5jb3JyZWN0IHR5cGluZ3NcbiAgbGF5ZXJJZCA9IGBtZ2wtbWFya2Vycy1mb3ItY2x1c3RlcnMtJHt1bmlxSWQrK31gO1xuXG4gIHByaXZhdGUgc3ViID0gbmV3IFN1YnNjcmlwdGlvbigpO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgbWFwU2VydmljZTogTWFwU2VydmljZSxcbiAgICBwcml2YXRlIENoYW5nZURldGVjdG9yUmVmOiBDaGFuZ2VEZXRlY3RvclJlZixcbiAgICBwcml2YXRlIHpvbmU6IE5nWm9uZVxuICApIHt9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIGNvbnN0IGNsdXN0ZXJEYXRhVXBkYXRlID0gKCkgPT5cbiAgICAgIGZyb21FdmVudDxNYXBTb3VyY2VEYXRhRXZlbnQ+KHRoaXMubWFwU2VydmljZS5tYXBJbnN0YW5jZSwgJ2RhdGEnKS5waXBlKFxuICAgICAgICBmaWx0ZXIoXG4gICAgICAgICAgKGUpID0+XG4gICAgICAgICAgICBlLnNvdXJjZUlkID09PSB0aGlzLnNvdXJjZSAmJlxuICAgICAgICAgICAgZS5zb3VyY2VEYXRhVHlwZSAhPT0gJ21ldGFkYXRhJyAmJlxuICAgICAgICAgICAgdGhpcy5tYXBTZXJ2aWNlLm1hcEluc3RhbmNlLmlzU291cmNlTG9hZGVkKHRoaXMuc291cmNlKVxuICAgICAgICApXG4gICAgICApO1xuICAgIGNvbnN0IHN1YiA9IHRoaXMubWFwU2VydmljZS5tYXBDcmVhdGVkJFxuICAgICAgLnBpcGUoXG4gICAgICAgIHN3aXRjaE1hcChjbHVzdGVyRGF0YVVwZGF0ZSksXG4gICAgICAgIHN3aXRjaE1hcCgoKSA9PlxuICAgICAgICAgIG1lcmdlKFxuICAgICAgICAgICAgZnJvbUV2ZW50KHRoaXMubWFwU2VydmljZS5tYXBJbnN0YW5jZSwgJ21vdmUnKSxcbiAgICAgICAgICAgIGZyb21FdmVudCh0aGlzLm1hcFNlcnZpY2UubWFwSW5zdGFuY2UsICdtb3ZlZW5kJylcbiAgICAgICAgICApLnBpcGUoc3RhcnRXaXRoKHVuZGVmaW5lZCkpXG4gICAgICAgIClcbiAgICAgIClcbiAgICAgIC5zdWJzY3JpYmUoKCkgPT4ge1xuICAgICAgICB0aGlzLnpvbmUucnVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLnVwZGF0ZUNsdXN0ZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB0aGlzLnN1Yi5hZGQoc3ViKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuc3ViLnVuc3Vic2NyaWJlKCk7XG4gIH1cblxuICB0cmFja0J5Q2x1c3RlclBvaW50KF9pbmRleDogbnVtYmVyLCBjbHVzdGVyUG9pbnQ6IE1hcGJveEdlb0pTT05GZWF0dXJlKSB7XG4gICAgcmV0dXJuIGNsdXN0ZXJQb2ludC5pZDtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlQ2x1c3RlcigpIHtcbiAgICAvLyBJbnZhbGlkIHF1ZXJ5UmVuZGVyZWRGZWF0dXJlcyB0eXBpbmdcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IHBhcmFtczogYW55ID0geyBsYXllcnM6IFt0aGlzLmxheWVySWRdIH07XG4gICAgaWYgKCF0aGlzLnBvaW50VHBsKSB7XG4gICAgICBwYXJhbXMuZmlsdGVyID0gWyc9PScsICdjbHVzdGVyJywgdHJ1ZV07XG4gICAgfVxuICAgIHRoaXMuY2x1c3RlclBvaW50cyA9XG4gICAgICB0aGlzLm1hcFNlcnZpY2UubWFwSW5zdGFuY2UucXVlcnlSZW5kZXJlZEZlYXR1cmVzKHBhcmFtcyk7XG4gICAgdGhpcy5DaGFuZ2VEZXRlY3RvclJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxufVxuIl19